# USER ACCOUNTS MANAGEMENT

User management in Linux involves the creation, modification, and removal of user accounts, as well as the management of associated permissions and privileges. It is a crucial aspect of system administration, ensuring secure and efficient access to resources on the system.
The two main folders involved in user management are `/etc/passwd` and `/etc/shadow`. Here are some key notes on user management in Linux:

`/etc/passwd`:

This file contains essential information about each user account on the system. Each line represents a user account and is composed of several fields separated by colons (:). Fields include username, password placeholder (actual password hash stored in /etc/shadow), UID, GID, user's full name or description, home directory, and login shell.

Example: `backup:x:34:34:backup:/var/backups:/usr/sbin/nologin`
- `backup`: This is the username of the user.
- `x`: This field traditionally held the hashed password of the user. However, modern systems typically store the password hashes in the - /etc/shadow file for security reasons. The x here indicates that the password hash is stored in the /etc/shadow file.
- `34`: This is the numerical user ID (UID) of the user. It uniquely identifies the user within the system.
- `34`: This is the numerical group ID (GID) of the user's primary group. It specifies which group the user belongs to.
- `backup`: This is the user's full name or a description of the user account.
- `/usr/sbin/nologin`: This is the user's shell. It specifies the command or program that will be executed when the user logs in. In this case, `/usr/sbin/nologin` indicates that the user cannot log in interactively, as it is a special shell that displays a message indicating that the account is not available for login. These settings are typically used for system accounts or accounts that should not have interactive shell access for security or administrative reasons.

`/etc/shadow`:

This file stores user account passwords in an encrypted format, enhancing security by protecting password information. Each line represents a user account and is composed of several fields separated by colons (:). Fields include username, encrypted password, password change and expiration information, and other account-related settings. The password field typically contains a hash generated using a hashing algorithm, along with a salt for added security.

Example: `seun:$y$j9T$aByJlLDW1APOvddbxH0oC1$aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8:19733:5:99999:7:60:15050:`
- `seun`: This is the username of the user.
- `$y$`: This field indicates the type of hashing algorithm used to generate the hash. In this case, $y$ typically represents bcrypt hashing.
- `j9T$aByJlLDW1APOvddbxH0oC1`: This is the hash value generated by the bcrypt hashing algorithm. It represents the hashed password.
- `aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8`: This appears to be the salt value used during the hashing process. The salt is combined with the password before hashing to add randomness and strengthen security.
- `19733:` This field represents the number of days since the Unix epoch (January 1, 1970) when the password was last changed.
- `5:` This field represents the minimum number of days required between password changes.
- `99999:` This field represents the maximum number of days the password is valid before it must be changed.
- `7:` This field represents the number of days before a password change is required for a warning to be issued.
- `60`: This field represents the number of days after the password expiration date that the account is disabled.
- `15050`: This field represents the date when the account was last used, measured in days since the Unix epoch.


### HASH PASSWORD FORMAT EXPLAINED

In Linux and many other systems, passwords are stored in a hashed format for security reasons. The format `$type$salt$hash` is commonly used to represent hashed passwords.

- $type: Indicates the type of hashing algorithm used to generate the hash. This part of the format specifies the algorithm used for password encryption. Different hash algorithms have different identifiers. For example: </br>
  - 1 typically represents MD5 hashing.</br>
  - 2a (blowfish) or 2y (Eksblowfish) typically represents bcrypt hashing.</br>
  - 5 typically represents SHA-256 hashing.</br>
  - 6 typically represents SHA-512 hashing.

<img width="526" alt="2y - Eksblowfish" src="https://github.com/ikechukwu25/Mastering-Linux/assets/64879420/98da424c-af14-47b4-a8ac-576504ff3898">

- $salt: The salt value used during the hashing process. A salt is a randomly generated string of characters that is combined with the password before hashing. Salting adds randomness to the hashing process and helps protect against dictionary and rainbow table attacks.

- $hash: The resulting hash value obtained after applying the hashing algorithm to the password concatenated with the salt. This value represents the final hashed password, which is stored in the system for authentication purposes.

Knowledge of hashing algorithms and salts aids in evaluating the security of password storage practices and implementing appropriate measures to protect sensitive user credentials.

We'll use the previous has in the shadow file as an example; 

`$y$j9T$aByJlLDW1APOvddbxH0oC1$aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8`
- $type: `$y$` indicates bcrypt hashing.
- $salt: `j9T` is the salt value used.
- $hash: `aByJlLDW1APOvddbxH0oC1` is the resulting hash of the password concatenated with the salt.
- `iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8`: This is the final hash value obtained after applying the bcrypt hashing algorithm, representing the hashed password. It is the output of the password hashing process and is stored in the system for authentication purposes.


## SECURITY

The `/etc/shadow` file contains critical security information related to user passwords on Unix-like systems. Each entry in this file represents a user account and includes various fields about password management and security policies. Understanding and managing entries in /etc/shadow is essential for maintaining the integrity and security of user authentication on the system. 

Here are the crucial parameters extracted from the /etc/shadow entry for the user "seun"  seun:`$y$j9T$aByJlLDW1APOvddbxH0oC1$aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8`:19733:5:99999:7:60:15050:

- Password: `$y$j9T$aByJlLDW1APOvddbxH0oC1$aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8`</br>
The password field contains the encrypted password for the account. This very long string is a one-way encryption, meaning that it can't be "reversed" to determine the original password.
  
- Last Change: `19733` </br>
This field contains a number that represents the last time the password was changed. The number 19733 is the number of days since January 1, 1970 (called the **Epoch**).

- Minimum: `5` </br>
This field indicates the minimum number of days between password changes. It is one of the password aging fields; a non-zero value in this field indicates that after a user changes their password, the password can't be changed again for the specified number of days, 5 days in this example.

- Maximum: `99999` </br>
This field indicates the maximum number of days the password is valid. It is used to force users to change their passwords on a regular basis. A value of 30 in this field means the user must change their password at least every 30 days to avoid having their account locked out.</br>
Setting a maximum password age without a corresponding minimum password age could allow users to reset their password to the original value immediately after changing it, potentially undermining the security intention of regular password changes. Therefore, it's advisable to set both minimum and maximum password ages to enforce password rotation policies effectively.

- Warn:  `7` </br>
If the maximum field is set, the warning field indicates the number of days before password expiry that the system warns the user. 

- Inactive: `60` </br>
If the user ignores the warnings and exceeds the password timeframe, their account will be locked out. In that case, the inactive field provides the user with a "grace" period in which their password can be changed, but only during the login process. If the inactive field is set to 60, the user has 60 days to change to a new password. If they fail to do so, then the administrator would be needed to reset the password for the user.

- Expire: `15050` </br>
This field indicates the day the account will expire, represented by the number of days from January 1, 1970. An expired account is locked, not deleted, meaning the administrator can reset the password to unlock the account

N/B: In addition to the grep command, another technique for retrieving user information contained in the `/etc/passwd` and `/etc/shadow` files is to use the `getent` command. 

`ikechukwu@ubuntu-22-04-3:~$ getent passwd seun`
`seun:$y$j9T$aByJlLDW1APOvddbxH0oC1$aUSViRiZM.iy8qnvsJviLk78cfXh40p1YzGh5LTnyO8:19733:5:99999:7:60:15050:`


# SYSTEM ACCOUNTS

System accounts are typically used for running background services (daemons) and have UID values in the reserved range (1-999 or 1-499). Exceptions include accounts like nfsnobody with UID 65534.

Regular user accounts typically have UID values greater than 500 (or 1,000 on some systems), while the root user, which has special access to the system, is assigned a UID of 0.

Accounts with User IDs (UIDs) ranging from 1 to 499 are known as system accounts. They are intended for services and system processes rather than user login.

System accounts have some fields in the `/etc/passwd` and `/etc/shadow` files that are different than other accounts. For example, system accounts rarely have home directories as they typically are not used to create or store files. In the `/etc/passwd` file, system accounts have a non-login program in the shell field. For example: </br>

`sshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin`


### USER ACCOUNT INFORMATION

| Username | Terminal | Login time | Display |
|-----|-----|-----|-----|
| root | tty2 | 2013-10-11 10:00 |   |
| sysadmin | pts/0 | 2013-10-11 09:59 | (:0.0) |	

This table indicates which terminal window the user is working in. If the terminal name starts with tty, then this is an indication of a local login, as this is a regular command line terminal. If the terminal name starts with pts, then this indicates the user is using a pseudo-terminal or running a process that acts as a terminal.


### USER ACCOUNT MONITORING 

- The `who` command in Unix-like operating systems is used to display information about users who are currently logged in to the system. It has several options for displaying system status information. For example, the `-b` option shows the last time the system started (booted), and the `-r` option shows the time the system reached the current run level:</br></br>
  `ikechukwu@ubuntu-22-04-3:~$ who -b -r`</br>
         system boot  	2013-10-11 09:54</br>
         run-level 5    2013-10-11 09:54

- The first line of output from the `w` command is identical to that of the `uptime` command. It shows the current time, how long the system has been running, the total number of users currently logged on and the load on the system averaged over the last 1, 5, and 15-minute time periods. Load average is CPU utilization where, for a single-core system, a value of 1 would mean 100% CPU usage during that period of time. For a dual-core system, it would mean 50% CPU usage, and for a quad-core system, it would mean 25% CPU usage.</br></br>
The following describes the rest of the output of the `w` command:

| Column | Terminal	| Description |
|-----|-----|-----|
| USER	| root	| The name of the user who is logged in. |
| TTY	| tty2	| Which terminal window the user is working in. | 
| FROM	| example.com	| Where the user logged in from. |
| LOGIN@	| 10:00	| When the user logged in. |
| IDLE	| 43:44	| How long the user has been idle since the last command was executed? |
| JCPU	| 0.01s	| The total CPU time used by all processes run since login. |
| PCPU	| 0.01s	| The total CPU time for the current process. |
| WHAT	| -bash	| The current process that the user is running. |

- The `uptime` command is a useful tool for system administrators and users alike, providing essential information about the current system's status. By running uptime in the terminal, users can quickly obtain key details such as how long the system has been running since the last reboot (uptime), the average system load over different time intervals, and the number of users currently logged in.</br></br>
- The `last` command reads the entire login history from the `/var/log/wtmp` file and displays all logins and reboot records by default. An interesting detail of the reboot records is that it displays the version of the Linux kernel that was booted instead of the login location. The `/var/log/wtmp` file keeps a log of all users who have logged in and out of the system.</br></br>
The `last` command is slightly different from the `who` and `w` commands. By default, it also shows the username, terminal, and login location, not just of the current login sessions, but previous sessions as well.</br></br>
The `who` command reads from the `/var/run/utmp` file which logs current users, while the `last` command reads from the `/var/log/wtmp` file, which keeps a history of all user logins.

- The `whoami` command provides a quick way to determine the username of the current user without any additional information. For example:</br>
  `ikechukwu@ubuntu-22-04-3:~$ whoami`</br>
  The output will display the username - `ikechukwu`
- The `who am i` command provides more detailed information about the current user's session, including the username ("ikechukwu"), terminal ("pts/0"), login time, and IP address (if available). For example:</br>
  `ikechukwu    pts/0    2024-04-02 09:30 (192.168.1.100)`
- The `id` command serves as a versatile tool for displaying essential information about users and groups on a Linux system. By executing `id` in the terminal followed by a username or group name (or without arguments to display information about the current user), users can obtain details such as the user ID (UID), group ID (GID), and supplementary group memberships associated with the specified user or group.


# MANAGING USERS AND GROUPS

On some distributions, creating a new user account also automatically creates a group account for the user, called a User Private Group (UPG). On these systems, the group and username would be the same, and the only member of this new group would be the new user. For distributions that do not create a UPG, new users are typically given the users group as their primary group. 

If you already have planned which users and groups you want, it is more efficient to create your groups first and create your users with their group memberships. Otherwise, if you create your users first, and then your groups, you'll need to take an extra step to modify your users to make them members of your groups.


### GROUPS

The most common reason to create a group is to provide a way for users to share files. For example, if several people work together on the same project and need to be able to collaborate on documents stored in files for the project. In this scenario, the administrator can make these people members of a common group, change the directory ownership to the new group, and set permissions on the directory that allows members of the group to access the files.

After creating or modifying a group, you can verify the changes by viewing the group configuration information in the `/etc/group` file with the `grep` command. If working with network-based authentication services, then the `getent` command can show you both local and network-based groups. For example:

`grep pattern filename` </br>
`getent database record`</br>

`grep username /etc/passwd` = shows the user ID and the group ID


**Creating a New Group**

The `groupadd` command can be executed by the root user to create a new group. The command requires only the name of the group to be created. The -g option can be used to specify a group ID for the new group:

`root@ubuntu-22-04-3:~# groupadd -g 1005 research` </br>
`root@ubuntu-22-04-3:~# grep research /etc/group`</br>
`research:x:1005:`


**User Private Groups (UPGs)**

In some Linux distributions, particularly those based upon Red Hat, when a user ID (UID) is created, a user private group (UPG) is also created with that user as its only member. In these distributions, the UID and the ID of the UPG are supposed to match (be the same number).

Therefore, you should avoid creating GIDs in the same numeric ranges where you expect to create UIDs, to avoid a conflict between a GID you create and a UPG number that is created to match a UID.

There may be times at which you want to assign a lower GID value. To accomplish this, use the `-r` option which assigns the new group a GID that is less than the lowest standard GID.


**Modifying Group Properties**

The `groupmod` command can be used to either change the name of a group with the `-n` option or change the GID for the group with the -g option.
Because the system defines the group by the GID, not the group name.

To search for all files that are owned by just a GID (not associated with a group name) use the `-nogroup` option of the find command: For example: </br>
`root@ubuntu-22-04-3:~# find / -nogroup`</br>
`/root/index.html`

If you decide to delete a group with the `groupdel` command, be aware that any files that are owned by that group will become orphaned.

Only supplemental groups can be deleted, so if any group is the primary group for any user, it cannot be deleted. The administrator can modify which group is a user's primary group, so a group that was being used as a primary group can be made into a supplemental group and then can be deleted.

The `groups` command displays all groups to which the current user belongs, with the primary group listed first. This provides users with insight into their group memberships.

By following these guidelines, administrators can effectively manage groups to enhance collaboration and resource access for users in a Linux environment.

Creating and configuring user accounts in Linux involves various options and settings to tailor user environments according to specific requirements. Here's an extensive overview:


### CONFIGURING USER ACCOUNTS IN LINUX

The `useradd` command provides options to view or modify default user configuration values. These settings, such as the default group, home directory, shell, expiration date, and inactive period, can be managed using the `-D` option or by editing the `/etc/default/useradd` file. 


**Example User Creation**

`sudo useradd -m -d /home/iyke -c "DevOps Engineer" -s /bin/bash -G sudo,adm,mail iyke`: </br>
This command effectively creates a new user account named "iyke" with the specified home directory, login shell, user comment, and supplementary groups.

The `-m` creates the user's home directory if it doesn't exist.
The `-d` option specifies the new directory name or the specific location you would like to create it. 
The `-c` option sets a custom comment or user description.
The `-s` option defines a custom login shell for the user.
The `-G` option is used to select a secondary group. 

Additional important options include; 

The `-b` option specifies a base directory for the user's home directory.
The `-e` option sets a different expiration date for the user account.
The `-f` option adjusts the inactive period for the user.
The `-g` option allows setting a different primary group for a new user account.
The `-u` option allows specifying a custom UID for the user account. For compatibility, it's recommended to keep UID values below 60,000.

`sudo useradd -e 2023-11-6 user2` = This command is used to create a temporary user, then you need to specify an expiration date for the account, using the -e option. 

`root@ubuntu-22-04-3:~# useradd -u 1009 -g users -G sales,research -m -c 'Jane Doe' jane`: </br>
This command creates a user named "jane" with UID 1009, primary group users, and supplementary groups sales and research, along with a custom comment, can be achieved with the following command

By leveraging these options and configurations, administrators can efficiently manage user accounts while ensuring optimal security and usability within the Linux environment.

The `useradd` command serves as the backend utility for `adduser`, offering a more direct approach to user creation. While `useradd` requires precise parameterization, adduser provides a friendlier interface, abstracting away complexities. Both commands fulfill the same purpose which is adding new users to the system. Notably, useradd automatically generates the user's home directory upon creation.

Similarly, `userdel` and deluser are counterparts in the user management realm, both facilitating the removal of users from the system.


**Configuration Files**

All information about a user is stored in the following files - `shadow`, `passwd`, `group`, `gshadow`, `login.defs` > all under /etc/ directory

The `/etc/login.defs` file is a configuration file that defines default settings and policies for user account management and login behavior. Administrators use this file to specify parameters such as password expiration, password complexity requirements, and default user environment settings.

The gshadow file is similar to the shadow file, gshadow stores encrypted passwords and security-related information for group accounts. It provides additional security measures for group administration.


**Standardizing User Environments**

The `SKEL` variable and the `-k` option in user management tools like `useradd` ensure consistency in configuring new user accounts.

By setting the `SKEL` variable to a directory containing predefined configurations, known as the skeleton directory, administrators can standardize user environments. For instance, executing:

`useradd -m -k /etc/skel_custom username` = This command creates a new user with customized settings from the specified skeleton directory.

Moreover, the `-k` option allows administrators to override the default skeleton directory, tailoring user environments based on individual requirements or roles.

In essence, utilizing the `SKEL` variable and the `-k` option streamlines user management, maintains uniformity in user setups, and facilitates tailored configurations to suit organizational needs.


**User Mask (UMASK)**

The UMASK value which stands for "user file creation mask", defines the default permissions that are subtracted from the maximum permissions when a new file or directory is created. The default format is 0002. 

The default permissions for directories are usually 0777 (rwxrwxrwx), which means read, write, and execute permissions are granted to the owner, group, and others.

The default permissions for files are typically 0666 (rw-rw-rw-), which means read and write permissions are granted to the owner, group, and others.

However, these permissions are often modified by the umask value, which masks out certain permissions when new files and directories are created. The default permissions are determined when the umask value is subtracted from the maximum allowable default permissions.

For example, if the umask is set to 0022, which is a common value, it will mask out the write permission for the group and others when new files are created, resulting in default permissions of 0644 (rw-r--r--). Similarly, for directories, the default permissions would be 0755 (rwxr-xr-x).

The maximum default permissions are different for files and directories:
||||
|-----|-----|-----|
| file	| 666	| rw-rw-rw- |
| directories |	777	| rwxrwxrwx |

Permanently changing a user's umask requires modifying the `.bashrc` file located in that user's home directory - `vim .bashrc`


**Modifying Group Properties**

The usermod command allows administrators to modify user account properties directly from the command line. It provides options to change the user's login shell (-s), home directory (-d), primary group (-g), supplementary groups (-G), and more.

`root@ubuntu-22-04-3:~# usermod -aG development jane` = The command is used to add the user "jane" to the supplementary group "development" without removing the user from any of their current supplementary groups.

The `usermod` command offers many options for modifying an existing user account. Many of these options are also available with the `useradd` command at the time the account is created. The following chart provides a summary of the `usermod` options:

| Short Option |	Long Option	| Description |
|-----|-----|-----|
| -c	| COMMENT	| Sets the value of the GECOS or comment field to COMMENT. |
| -d HOME_DIR	| --home HOME_DIR	| Sets HOME_DIR as a new home directory for the user. |
| -e EXPIRE_DATE	| --expiredate EXPIRE_DATE	| Set account expiration date to EXPIRE_DATE. |
| -f INACTIVE	| --inactive INACTIVE	| Set account to permit login for INACTIVE days after password expires. |
| -g GROUP	| --gid GROUP	| Set GROUP as the primary group. |
| -G GROUPS	| --groups GROUPS	| Set supplementary groups to a list specified in GROUPS. |
| -a	| --append	| Append the user's supplemental groups with those specified by the `-G` option. |
| -h	| --help	| Show the help for the `usermod` command. |
| -l NEW_LOGIN	| --login NEW_LOGIN	| Change the user's login name. |
| -L	| --lock | Lock the user account. |
| -s SHELL	| --shell SHELL	| Specify the login shell for the account. |
| -u NEW_UID	| --uid NEW_UID	| Specify the user's UID to be NEW_UID. |
| -U	| --unlock	| Unlock the user account. |

